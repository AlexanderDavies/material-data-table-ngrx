{"version":3,"sources":["src/material/material-autocomplete.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","tslib","cdk","a11y","coercion","core","common","overlay","bidi","keycodes","platform","portal","scrolling","forms","formField","rxjs","operators","this","core$1","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","source","option","_MatAutocompleteMixinBase","mixinDisableRipple","MatAutocompleteBase","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","MatAutocomplete","_super","_changeDetectorRef","_elementRef","defaults","_this","call","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","closed","_classList","id","_autoActiveFirstOption","__extends","Object","defineProperty","prototype","get","enumerable","configurable","set","value","coerceBooleanProperty","length","split","reduce","classList","className","trim","_setVisibilityClasses","nativeElement","ngAfterContentInit","_keyManager","ActiveDescendantKeyManager","options","withWrap","_setVisibility","_setScrollTop","scrollTop","panel","_getScrollTop","markForCheck","_emitSelectEvent","event","emit","decorators","type","Component","args","selector","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","exportAs","inputs","host","class","providers","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","styles","ctorParameters","ChangeDetectorRef","ElementRef","undefined","Inject","propDecorators","ViewChild","TemplateRef","static","ContentChildren","MatOption","descendants","optionGroups","MatOptgroup","Input","panelWidth","Output","MatAutocompleteOrigin","elementRef","Directive","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","Subscription","EMPTY","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","defer","merge","apply","__spread","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","_scrollStrategy","ngAfterViewInit","window","runOutsideAngular","addEventListener","_supportsShadowDom","element","rootNode","getRootNode","_isInsideShadowRoot","ShadowRoot","ngOnChanges","changes","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","ngOnDestroy","removeEventListener","unsubscribe","_destroyPanel","complete","openPanel","_attachOverlay","_floatLabel","closePanel","_resetLabel","hasAttached","detach","_closingActionsSubscription","detectChanges","tabOut","filter","_getOutsideClickStream","detachments","of","MatOptionSelectionChange","activeItem","fromEvent","clickTarget","composedPath","target","contains","overlayElement","writeValue","Promise","resolve","then","_setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","_scrollToOption","_handleInput","parseFloat","_previousValue","_handleFocus","shouldAnimate","floatLabel","_animateAndLockLabel","index","activeItemIndex","labelCount","_countGroupLabelsBeforeOption","newScrollPosition","_getOptionScrollPosition","_subscribeToClosingActions","firstStable","optionChanges","tap","reapplyLastPosition","delay","wasOpen","panelClosingActions","subscribe","_setValueAndClose","dispose","toDisplay","inputValue","_control","_clearPreviousSelectedOption","focus","skip","forEach","selected","deselect","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","create","_getOverlayConfig","keydownEvents","altKey","next","stopPropagation","change","attach","OverlayConfig","positionStrategy","_getOverlayPosition","direction","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","belowPosition","originX","originY","overlayX","overlayY","abovePosition","panelClass","withPositions","connectedTo","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","setActiveItem","readOnly","[attr.autocomplete]","[attr.role]","[attr.aria-autocomplete]","[attr.aria-activedescendant]","[attr.aria-expanded]","[attr.aria-owns]","[attr.aria-haspopup]","(focusin)","(blur)","(input)","(keydown)","ViewContainerRef","NgZone","Directionality","Optional","MatFormField","Host","DOCUMENT","ViewportRuler","autocompleteDisabled","MatAutocompleteModule","NgModule","imports","MatOptionModule","OverlayModule","MatCommonModule","CommonModule","declarations","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/core'), require('@angular/material/core'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/bidi'), require('@angular/cdk/keycodes'), require('@angular/cdk/platform'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('@angular/forms'), require('@angular/material/form-field'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete', ['exports', 'tslib', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/core', '@angular/material/core', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/bidi', '@angular/cdk/keycodes', '@angular/cdk/platform', '@angular/cdk/portal', '@angular/cdk/scrolling', '@angular/forms', '@angular/material/form-field', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = {}), global.tslib, global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.core, global.ng.material.core, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.bidi, global.ng.cdk.keycodes, global.ng.cdk.platform, global.ng.cdk.portal, global.ng.cdk.scrolling, global.ng.forms, global.ng.material.formField, global.rxjs, global.rxjs.operators));\n}(this, (function (exports, tslib, a11y, coercion, core, core$1, common, overlay, bidi, keycodes, platform, portal, scrolling, forms, formField, rxjs, operators) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Autocomplete IDs need to be unique across components, so this counter exists outside of\n     * the component definition.\n     */\n    var _uniqueAutocompleteIdCounter = 0;\n    /** Event object that is emitted when an autocomplete option is selected. */\n    var MatAutocompleteSelectedEvent = /** @class */ (function () {\n        function MatAutocompleteSelectedEvent(\n        /** Reference to the autocomplete panel that emitted the event. */\n        source, \n        /** Option that was selected. */\n        option) {\n            this.source = source;\n            this.option = option;\n        }\n        return MatAutocompleteSelectedEvent;\n    }());\n    // Boilerplate for applying mixins to MatAutocomplete.\n    /** @docs-private */\n    var MatAutocompleteBase = /** @class */ (function () {\n        function MatAutocompleteBase() {\n        }\n        return MatAutocompleteBase;\n    }());\n    var _MatAutocompleteMixinBase = core$1.mixinDisableRipple(MatAutocompleteBase);\n    /** Injection token to be used to override the default options for `mat-autocomplete`. */\n    var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core.InjectionToken('mat-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n    });\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n        return { autoActiveFirstOption: false };\n    }\n    var MatAutocomplete = /** @class */ (function (_super) {\n        tslib.__extends(MatAutocomplete, _super);\n        function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\n            var _this = _super.call(this) || this;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._elementRef = _elementRef;\n            /** Whether the autocomplete panel should be visible, depending on option length. */\n            _this.showPanel = false;\n            _this._isOpen = false;\n            /** Function that maps an option's control value to its display value in the trigger. */\n            _this.displayWith = null;\n            /** Event that is emitted whenever an option from the list is selected. */\n            _this.optionSelected = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is opened. */\n            _this.opened = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is closed. */\n            _this.closed = new core.EventEmitter();\n            _this._classList = {};\n            /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n            _this.id = \"mat-autocomplete-\" + _uniqueAutocompleteIdCounter++;\n            _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n            return _this;\n        }\n        Object.defineProperty(MatAutocomplete.prototype, \"isOpen\", {\n            /** Whether the autocomplete panel is open. */\n            get: function () { return this._isOpen && this.showPanel; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"autoActiveFirstOption\", {\n            /**\n             * Whether the first option should be highlighted when the autocomplete panel is opened.\n             * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n             */\n            get: function () { return this._autoActiveFirstOption; },\n            set: function (value) {\n                this._autoActiveFirstOption = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"classList\", {\n            /**\n             * Takes classes set on the host mat-autocomplete element and applies them to the panel\n             * inside the overlay container to allow for easy styling.\n             */\n            set: function (value) {\n                if (value && value.length) {\n                    this._classList = value.split(' ').reduce(function (classList, className) {\n                        classList[className.trim()] = true;\n                        return classList;\n                    }, {});\n                }\n                else {\n                    this._classList = {};\n                }\n                this._setVisibilityClasses(this._classList);\n                this._elementRef.nativeElement.className = '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocomplete.prototype.ngAfterContentInit = function () {\n            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();\n            // Set the initial visibility state.\n            this._setVisibility();\n        };\n        /**\n         * Sets the panel scrollTop. This allows us to manually scroll to display options\n         * above or below the fold, as they are not actually being focused when active.\n         */\n        MatAutocomplete.prototype._setScrollTop = function (scrollTop) {\n            if (this.panel) {\n                this.panel.nativeElement.scrollTop = scrollTop;\n            }\n        };\n        /** Returns the panel's scrollTop. */\n        MatAutocomplete.prototype._getScrollTop = function () {\n            return this.panel ? this.panel.nativeElement.scrollTop : 0;\n        };\n        /** Panel should hide itself when the option list is empty. */\n        MatAutocomplete.prototype._setVisibility = function () {\n            this.showPanel = !!this.options.length;\n            this._setVisibilityClasses(this._classList);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Emits the `select` event. */\n        MatAutocomplete.prototype._emitSelectEvent = function (option) {\n            var event = new MatAutocompleteSelectedEvent(this, option);\n            this.optionSelected.emit(event);\n        };\n        /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n        MatAutocomplete.prototype._setVisibilityClasses = function (classList) {\n            classList['mat-autocomplete-visible'] = this.showPanel;\n            classList['mat-autocomplete-hidden'] = !this.showPanel;\n        };\n        MatAutocomplete.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-autocomplete',\n                        template: \"<ng-template>\\n  <div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        exportAs: 'matAutocomplete',\n                        inputs: ['disableRipple'],\n                        host: {\n                            'class': 'mat-autocomplete'\n                        },\n                        providers: [\n                            { provide: core$1.MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\n                        ],\n                        styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatAutocomplete.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef },\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatAutocomplete.propDecorators = {\n            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],\n            panel: [{ type: core.ViewChild, args: ['panel',] }],\n            options: [{ type: core.ContentChildren, args: [core$1.MatOption, { descendants: true },] }],\n            optionGroups: [{ type: core.ContentChildren, args: [core$1.MatOptgroup, { descendants: true },] }],\n            displayWith: [{ type: core.Input }],\n            autoActiveFirstOption: [{ type: core.Input }],\n            panelWidth: [{ type: core.Input }],\n            optionSelected: [{ type: core.Output }],\n            opened: [{ type: core.Output }],\n            closed: [{ type: core.Output }],\n            classList: [{ type: core.Input, args: ['class',] }]\n        };\n        return MatAutocomplete;\n    }(_MatAutocompleteMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Directive applied to an element to make it usable\n     * as a connection point for an autocomplete panel.\n     */\n    var MatAutocompleteOrigin = /** @class */ (function () {\n        function MatAutocompleteOrigin(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n        MatAutocompleteOrigin.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matAutocompleteOrigin]',\n                        exportAs: 'matAutocompleteOrigin',\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteOrigin.ctorParameters = function () { return [\n            { type: core.ElementRef }\n        ]; };\n        return MatAutocompleteOrigin;\n    }());\n\n    /**\n     * The following style constants are necessary to save here in order\n     * to properly calculate the scrollTop of the panel. Because we are not\n     * actually focusing the active item, scroll must be handled manually.\n     */\n    /** The height of each autocomplete option. */\n    var AUTOCOMPLETE_OPTION_HEIGHT = 48;\n    /** The total height of the autocomplete panel. */\n    var AUTOCOMPLETE_PANEL_HEIGHT = 256;\n    /** Injection token that determines the scroll handling while the autocomplete panel is open. */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core.InjectionToken('mat-autocomplete-scroll-strategy');\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition(); };\n    }\n    /** @docs-private */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n        provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n        deps: [overlay.Overlay],\n        useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n    };\n    /**\n     * Provider that allows the autocomplete to register as a ControlValueAccessor.\n     * @docs-private\n     */\n    var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatAutocompleteTrigger; }),\n        multi: true\n    };\n    /**\n     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n     * @docs-private\n     */\n    function getMatAutocompleteMissingPanelError() {\n        return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n            'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n            'you\\'re attempting to open it after the ngAfterContentInit hook.');\n    }\n    var MatAutocompleteTrigger = /** @class */ (function () {\n        function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, \n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        _viewportRuler) {\n            var _this = this;\n            this._element = _element;\n            this._overlay = _overlay;\n            this._viewContainerRef = _viewContainerRef;\n            this._zone = _zone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._formField = _formField;\n            this._document = _document;\n            this._viewportRuler = _viewportRuler;\n            this._componentDestroyed = false;\n            this._autocompleteDisabled = false;\n            /** Whether or not the label state is being overridden. */\n            this._manuallyFloatingLabel = false;\n            /** Subscription to viewport size changes. */\n            this._viewportSubscription = rxjs.Subscription.EMPTY;\n            /**\n             * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n             * closed autocomplete from being reopened if the user switches to another browser tab and then\n             * comes back.\n             */\n            this._canOpenOnNextFocus = true;\n            /** Stream of keyboard events that can close the panel. */\n            this._closeKeyEventStream = new rxjs.Subject();\n            /**\n             * Event handler for when the window is blurred. Needs to be an\n             * arrow function in order to preserve the context.\n             */\n            this._windowBlurHandler = function () {\n                // If the user blurred the window while the autocomplete is focused, it means that it'll be\n                // refocused when they come back. In this case we want to skip the first focus event, if the\n                // pane was closed, in order to avoid reopening it unintentionally.\n                _this._canOpenOnNextFocus =\n                    _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;\n            };\n            /** `View -> model callback called when value changes` */\n            this._onChange = function () { };\n            /** `View -> model callback called when autocomplete has been touched` */\n            this._onTouched = function () { };\n            /**\n             * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n             * will render the panel underneath the trigger if there is enough space for it to fit in\n             * the viewport, otherwise the panel will be shown above it. If the position is set to\n             * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n             * whether it fits completely in the viewport.\n             */\n            this.position = 'auto';\n            /**\n             * `autocomplete` attribute to be set on the input element.\n             * @docs-private\n             */\n            this.autocompleteAttribute = 'off';\n            this._overlayAttached = false;\n            /** Stream of autocomplete option selections. */\n            this.optionSelections = rxjs.defer(function () {\n                if (_this.autocomplete && _this.autocomplete.options) {\n                    return rxjs.merge.apply(void 0, tslib.__spread(_this.autocomplete.options.map(function (option) { return option.onSelectionChange; })));\n                }\n                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n                // Return a stream that we'll replace with the real one once everything is in place.\n                return _this._zone.onStable\n                    .asObservable()\n                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelections; }));\n            });\n            this._scrollStrategy = scrollStrategy;\n        }\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"autocompleteDisabled\", {\n            /**\n             * Whether the autocomplete is disabled. When disabled, the element will\n             * act as a regular input and the user won't be able to open the panel.\n             */\n            get: function () { return this._autocompleteDisabled; },\n            set: function (value) {\n                this._autocompleteDisabled = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            if (typeof window !== 'undefined') {\n                this._zone.runOutsideAngular(function () {\n                    window.addEventListener('blur', _this._windowBlurHandler);\n                });\n                if (platform._supportsShadowDom()) {\n                    var element = this._element.nativeElement;\n                    var rootNode = element.getRootNode ? element.getRootNode() : null;\n                    // We need to take the `ShadowRoot` off of `window`, because the built-in types are\n                    // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\n                    this._isInsideShadowRoot = rootNode instanceof window.ShadowRoot;\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {\n            if (changes['position'] && this._positionStrategy) {\n                this._setStrategyPositions(this._positionStrategy);\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnDestroy = function () {\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('blur', this._windowBlurHandler);\n            }\n            this._viewportSubscription.unsubscribe();\n            this._componentDestroyed = true;\n            this._destroyPanel();\n            this._closeKeyEventStream.complete();\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelOpen\", {\n            /** Whether or not the autocomplete panel is open. */\n            get: function () {\n                return this._overlayAttached && this.autocomplete.showPanel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Opens the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.openPanel = function () {\n            this._attachOverlay();\n            this._floatLabel();\n        };\n        /** Closes the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.closePanel = function () {\n            this._resetLabel();\n            if (!this._overlayAttached) {\n                return;\n            }\n            if (this.panelOpen) {\n                // Only emit if the panel was visible.\n                this.autocomplete.closed.emit();\n            }\n            this.autocomplete._isOpen = this._overlayAttached = false;\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n                this._closingActionsSubscription.unsubscribe();\n            }\n            // Note that in some cases this can end up being called after the component is destroyed.\n            // Add a check to ensure that we don't try to run change detection on a destroyed view.\n            if (!this._componentDestroyed) {\n                // We need to trigger change detection manually, because\n                // `fromEvent` doesn't seem to do it at the proper time.\n                // This ensures that the label is reset when the\n                // user clicks outside.\n                this._changeDetectorRef.detectChanges();\n            }\n        };\n        /**\n         * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n         * within the viewport.\n         */\n        MatAutocompleteTrigger.prototype.updatePosition = function () {\n            if (this._overlayAttached) {\n                this._overlayRef.updatePosition();\n            }\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelClosingActions\", {\n            /**\n             * A stream of actions that should close the autocomplete panel, including\n             * when an option is selected, on blur, and when TAB is pressed.\n             */\n            get: function () {\n                var _this = this;\n                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(function () { return _this._overlayAttached; })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n                    this._overlayRef.detachments().pipe(operators.filter(function () { return _this._overlayAttached; })) :\n                    rxjs.of()).pipe(\n                // Normalize the output so we return a consistent type.\n                operators.map(function (event) { return event instanceof core$1.MatOptionSelectionChange ? event : null; }));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"activeOption\", {\n            /** The currently active option, coerced to MatOption type. */\n            get: function () {\n                if (this.autocomplete && this.autocomplete._keyManager) {\n                    return this.autocomplete._keyManager.activeItem;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Stream of clicks outside of the autocomplete panel. */\n        MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {\n            var _this = this;\n            return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))\n                .pipe(operators.filter(function (event) {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                var clickTarget = (_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                    event.target);\n                var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;\n                return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\n            }));\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.writeValue = function (value) {\n            var _this = this;\n            Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {\n            this._element.nativeElement.disabled = isDisabled;\n        };\n        MatAutocompleteTrigger.prototype._handleKeydown = function (event) {\n            var keyCode = event.keyCode;\n            // Prevent the default action on all escape key presses. This is here primarily to bring IE\n            // in line with other browsers. By default, pressing escape on IE will cause it to revert\n            // the input value to the one that it had on focus, however it won't dispatch any events\n            // which means that the model value will be out of sync with the view.\n            if (keyCode === keycodes.ESCAPE) {\n                event.preventDefault();\n            }\n            if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {\n                this.activeOption._selectViaInteraction();\n                this._resetActiveItem();\n                event.preventDefault();\n            }\n            else if (this.autocomplete) {\n                var prevActiveItem = this.autocomplete._keyManager.activeItem;\n                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;\n                if (this.panelOpen || keyCode === keycodes.TAB) {\n                    this.autocomplete._keyManager.onKeydown(event);\n                }\n                else if (isArrowKey && this._canOpen()) {\n                    this.openPanel();\n                }\n                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                    this._scrollToOption();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleInput = function (event) {\n            var target = event.target;\n            var value = target.value;\n            // Based on `NumberValueAccessor` from forms.\n            if (target.type === 'number') {\n                value = value == '' ? null : parseFloat(value);\n            }\n            // If the input has a placeholder, IE will fire the `input` event on page load,\n            // focus and blur, in addition to when the user actually changed the value. To\n            // filter out all of the extra events, we save the value on focus and between\n            // `input` events, and we check whether it changed.\n            // See: https://connect.microsoft.com/IE/feedback/details/885747/\n            if (this._previousValue !== value) {\n                this._previousValue = value;\n                this._onChange(value);\n                if (this._canOpen() && this._document.activeElement === event.target) {\n                    this.openPanel();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleFocus = function () {\n            if (!this._canOpenOnNextFocus) {\n                this._canOpenOnNextFocus = true;\n            }\n            else if (this._canOpen()) {\n                this._previousValue = this._element.nativeElement.value;\n                this._attachOverlay();\n                this._floatLabel(true);\n            }\n        };\n        /**\n         * In \"auto\" mode, the label will animate down as soon as focus is lost.\n         * This causes the value to jump when selecting an option with the mouse.\n         * This method manually floats the label until the panel can be closed.\n         * @param shouldAnimate Whether the label should be animated when it is floated.\n         */\n        MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {\n            if (shouldAnimate === void 0) { shouldAnimate = false; }\n            if (this._formField && this._formField.floatLabel === 'auto') {\n                if (shouldAnimate) {\n                    this._formField._animateAndLockLabel();\n                }\n                else {\n                    this._formField.floatLabel = 'always';\n                }\n                this._manuallyFloatingLabel = true;\n            }\n        };\n        /** If the label has been manually elevated, return it to its normal state. */\n        MatAutocompleteTrigger.prototype._resetLabel = function () {\n            if (this._manuallyFloatingLabel) {\n                this._formField.floatLabel = 'auto';\n                this._manuallyFloatingLabel = false;\n            }\n        };\n        /**\n         * Given that we are not actually focusing active options, we must manually adjust scroll\n         * to reveal options below the fold. First, we find the offset of the option from the top\n         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n         * the panel height + the option height, so the active option will be just visible at the\n         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n         * will become the offset. If that offset is visible within the panel already, the scrollTop is\n         * not adjusted.\n         */\n        MatAutocompleteTrigger.prototype._scrollToOption = function () {\n            var index = this.autocomplete._keyManager.activeItemIndex || 0;\n            var labelCount = core$1._countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n            if (index === 0 && labelCount === 1) {\n                // If we've got one group label before the option and we're at the top option,\n                // scroll the list to the top. This is better UX than scrolling the list to the\n                // top of the option, because it allows the user to read the top group's label.\n                this.autocomplete._setScrollTop(0);\n            }\n            else {\n                var newScrollPosition = core$1._getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n                this.autocomplete._setScrollTop(newScrollPosition);\n            }\n        };\n        /**\n         * This method listens to a stream of panel closing actions and resets the\n         * stream every time the option list changes.\n         */\n        MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\n            var _this = this;\n            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));\n            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(function () { return _this._positionStrategy.reapplyLastPosition(); }), \n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            operators.delay(0));\n            // When the zone is stable initially, and when the option list changes...\n            return rxjs.merge(firstStable, optionChanges)\n                .pipe(\n            // create a new stream of panelClosingActions, replacing any previous streams\n            // that were created, and flatten it so our stream only emits closing events...\n            operators.switchMap(function () {\n                var wasOpen = _this.panelOpen;\n                _this._resetActiveItem();\n                _this.autocomplete._setVisibility();\n                if (_this.panelOpen) {\n                    _this._overlayRef.updatePosition();\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                    // event, because we may not have emitted it when the panel was attached. This\n                    // can happen if the users opens the panel and there are no options, but the\n                    // options come in slightly later or as a result of the value changing.\n                    if (wasOpen !== _this.panelOpen) {\n                        _this.autocomplete.opened.emit();\n                    }\n                }\n                return _this.panelClosingActions;\n            }), \n            // when the first closing event occurs...\n            operators.take(1))\n                // set the value, close the panel, and complete.\n                .subscribe(function (event) { return _this._setValueAndClose(event); });\n        };\n        /** Destroys the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype._destroyPanel = function () {\n            if (this._overlayRef) {\n                this.closePanel();\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n        };\n        MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {\n            var toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n                this.autocomplete.displayWith(value) :\n                value;\n            // Simply falling back to an empty string if the display value is falsy does not work properly.\n            // The display value can also be the number zero and shouldn't fall back to an empty string.\n            var inputValue = toDisplay != null ? toDisplay : '';\n            // If it's used within a `MatFormField`, we should set it through the property so it can go\n            // through change detection.\n            if (this._formField) {\n                this._formField._control.value = inputValue;\n            }\n            else {\n                this._element.nativeElement.value = inputValue;\n            }\n            this._previousValue = inputValue;\n        };\n        /**\n         * This method closes the panel, and if a value is specified, also sets the associated\n         * control to that value. It will also mark the control as dirty if this interaction\n         * stemmed from the user.\n         */\n        MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {\n            if (event && event.source) {\n                this._clearPreviousSelectedOption(event.source);\n                this._setTriggerValue(event.source.value);\n                this._onChange(event.source.value);\n                this._element.nativeElement.focus();\n                this.autocomplete._emitSelectEvent(event.source);\n            }\n            this.closePanel();\n        };\n        /**\n         * Clear any previous selected option and emit a selection change event for this option\n         */\n        MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\n            this.autocomplete.options.forEach(function (option) {\n                if (option != skip && option.selected) {\n                    option.deselect();\n                }\n            });\n        };\n        MatAutocompleteTrigger.prototype._attachOverlay = function () {\n            var _this = this;\n            if (!this.autocomplete) {\n                throw getMatAutocompleteMissingPanelError();\n            }\n            var overlayRef = this._overlayRef;\n            if (!overlayRef) {\n                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n                overlayRef = this._overlay.create(this._getOverlayConfig());\n                this._overlayRef = overlayRef;\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                overlayRef.keydownEvents().subscribe(function (event) {\n                    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                    if (event.keyCode === keycodes.ESCAPE || (event.keyCode === keycodes.UP_ARROW && event.altKey)) {\n                        _this._resetActiveItem();\n                        _this._closeKeyEventStream.next();\n                        // We need to stop propagation, otherwise the event will eventually\n                        // reach the input itself and cause the overlay to be reopened.\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }\n                });\n                if (this._viewportRuler) {\n                    this._viewportSubscription = this._viewportRuler.change().subscribe(function () {\n                        if (_this.panelOpen && overlayRef) {\n                            overlayRef.updateSize({ width: _this._getPanelWidth() });\n                        }\n                    });\n                }\n            }\n            else {\n                // Update the trigger, panel width and direction, in case anything has changed.\n                this._positionStrategy.setOrigin(this._getConnectedElement());\n                overlayRef.updateSize({ width: this._getPanelWidth() });\n            }\n            if (overlayRef && !overlayRef.hasAttached()) {\n                overlayRef.attach(this._portal);\n                this._closingActionsSubscription = this._subscribeToClosingActions();\n            }\n            var wasOpen = this.panelOpen;\n            this.autocomplete._setVisibility();\n            this.autocomplete._isOpen = this._overlayAttached = true;\n            // We need to do an extra `panelOpen` check in here, because the\n            // autocomplete won't be shown if there are no options.\n            if (this.panelOpen && wasOpen !== this.panelOpen) {\n                this.autocomplete.opened.emit();\n            }\n        };\n        MatAutocompleteTrigger.prototype._getOverlayConfig = function () {\n            return new overlay.OverlayConfig({\n                positionStrategy: this._getOverlayPosition(),\n                scrollStrategy: this._scrollStrategy(),\n                width: this._getPanelWidth(),\n                direction: this._dir\n            });\n        };\n        MatAutocompleteTrigger.prototype._getOverlayPosition = function () {\n            var strategy = this._overlay.position()\n                .flexibleConnectedTo(this._getConnectedElement())\n                .withFlexibleDimensions(false)\n                .withPush(false);\n            this._setStrategyPositions(strategy);\n            this._positionStrategy = strategy;\n            return strategy;\n        };\n        /** Sets the positions on a position strategy based on the directive's input state. */\n        MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {\n            var belowPosition = {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'top'\n            };\n            var abovePosition = {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'bottom',\n                // The overlay edge connected to the trigger should have squared corners, while\n                // the opposite end has rounded corners. We apply a CSS class to swap the\n                // border-radius based on the overlay position.\n                panelClass: 'mat-autocomplete-panel-above'\n            };\n            var positions;\n            if (this.position === 'above') {\n                positions = [abovePosition];\n            }\n            else if (this.position === 'below') {\n                positions = [belowPosition];\n            }\n            else {\n                positions = [belowPosition, abovePosition];\n            }\n            positionStrategy.withPositions(positions);\n        };\n        MatAutocompleteTrigger.prototype._getConnectedElement = function () {\n            if (this.connectedTo) {\n                return this.connectedTo.elementRef;\n            }\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n        };\n        MatAutocompleteTrigger.prototype._getPanelWidth = function () {\n            return this.autocomplete.panelWidth || this._getHostWidth();\n        };\n        /** Returns the width of the input element, so the panel width can match it. */\n        MatAutocompleteTrigger.prototype._getHostWidth = function () {\n            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n        };\n        /**\n         * Resets the active item to -1 so arrow events will activate the\n         * correct options, or to 0 if the consumer opted into it.\n         */\n        MatAutocompleteTrigger.prototype._resetActiveItem = function () {\n            this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n        };\n        /** Determines whether the panel can be opened. */\n        MatAutocompleteTrigger.prototype._canOpen = function () {\n            var element = this._element.nativeElement;\n            return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n        };\n        MatAutocompleteTrigger.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"input[matAutocomplete], textarea[matAutocomplete]\",\n                        host: {\n                            'class': 'mat-autocomplete-trigger',\n                            '[attr.autocomplete]': 'autocompleteAttribute',\n                            '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                            '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                            '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                            '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                            '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                            '[attr.aria-haspopup]': '!autocompleteDisabled',\n                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                            // a little earlier. This avoids issues where IE delays the focusing of the input.\n                            '(focusin)': '_handleFocus()',\n                            '(blur)': '_onTouched()',\n                            '(input)': '_handleInput($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                        },\n                        exportAs: 'matAutocompleteTrigger',\n                        providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteTrigger.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: overlay.Overlay },\n            { type: core.ViewContainerRef },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: formField.MatFormField, decorators: [{ type: core.Optional }, { type: core.Host }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },\n            { type: scrolling.ViewportRuler }\n        ]; };\n        MatAutocompleteTrigger.propDecorators = {\n            autocomplete: [{ type: core.Input, args: ['matAutocomplete',] }],\n            position: [{ type: core.Input, args: ['matAutocompletePosition',] }],\n            connectedTo: [{ type: core.Input, args: ['matAutocompleteConnectedTo',] }],\n            autocompleteAttribute: [{ type: core.Input, args: ['autocomplete',] }],\n            autocompleteDisabled: [{ type: core.Input, args: ['matAutocompleteDisabled',] }]\n        };\n        return MatAutocompleteTrigger;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatAutocompleteModule = /** @class */ (function () {\n        function MatAutocompleteModule() {\n        }\n        MatAutocompleteModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [core$1.MatOptionModule, overlay.OverlayModule, core$1.MatCommonModule, common.CommonModule],\n                        exports: [\n                            MatAutocomplete,\n                            core$1.MatOptionModule,\n                            MatAutocompleteTrigger,\n                            MatAutocompleteOrigin,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                        providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                    },] }\n        ];\n        return MatAutocompleteModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;\n    exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER;\n    exports.MAT_AUTOCOMPLETE_VALUE_ACCESSOR = MAT_AUTOCOMPLETE_VALUE_ACCESSOR;\n    exports.MatAutocomplete = MatAutocomplete;\n    exports.MatAutocompleteModule = MatAutocompleteModule;\n    exports.MatAutocompleteOrigin = MatAutocompleteOrigin;\n    exports.MatAutocompleteSelectedEvent = MatAutocompleteSelectedEvent;\n    exports.MatAutocompleteTrigger = MatAutocompleteTrigger;\n    exports.getMatAutocompleteMissingPanelError = getMatAutocompleteMissingPanelError;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-autocomplete.umd.js.map\n"]}